__author__ = 'peter'
import os
from collections import namedtuple, OrderedDict
import copy
import numpy as np
import re
import datetime as dt

featureDesc = namedtuple("featureDescription", ['path', 'ext'])

class featureFilter(object):
    def __init__(self, baseFolder, featureLst):
        self.baseFolder = baseFolder
        if not type(featureLst) == list:
            featureLst = [featureLst]

        self.vialIdces = [0,1,2,3]
        self.filelists = []
        self.rngs = []
        self.featureLst = featureLst

        self.prepareFilelist()
        self.scanForFeatures()

    def prepareFilelist(self):
        self.filelists = {}

        for v in self.vialIdces:
            self.filelists[v] = {}
            for featDesc in self.featureLst:
                self.filelists[v][featDesc] = []


    def fileName2DateTime(self,  fn, ending="mp4"):
        """
        converts filename of video file to python datetime object

        Args:
            fn (string):
                                filename

        Returns:
            out (datetime object):
                                conversion of filename
        """

        basename = os.path.basename(fn)
        parts = re.split("[.]",  basename)
        date = re.split("[-]", parts[0])
        time = re.split("[-]", parts[1])

        if fn[-len(ending):] != ending:
            return -1

        if len(date) != 3:
            raise ValueError("mp4 file without proper date part discovered")
            return -1

        if len(time) < 3:
            raise ValueError("mp4 file without proper time part discovered")
            return -1

        out = dt.datetime(int(date[0]), int(date[1]), int(date[2]),
                          int(time[0]), int(time[1]), int(time[2]))

        return out

    def filelist2DateTime(self, filelist, extension):
        dtList = []
        for f in sorted(filelist):
            dtList += [self.fileName2DateTime(f, extension)]

        return dtList

    def findInteruptions(self, fileList, extension):
        """
        separates the filelist into ranges of consequent films, i.e. each
        range represents a batch of videos that share the same background model

        :note:`it is assumed that each consequtive file is 1 min long`

        Args:
            fileList (list of [datetime, path])
                                each element of this list can be generated by
                                :func:`fileName2DateTime`

        Returns:
            ranges of datetime that can be passed directly into
            :func:`setTimeRange`
        """
        # set file chunk size to 1 minute
        chunkSize = dt.time(0, 1)

        dtList = self.filelist2DateTime(fileList, extension)

        rngs = []
        start = None
        stop = None

        if len(fileList) < 2:
            raise ValueError("There are less then 2 files in the list. That usually means that a wrong folder was selected.")

        for i in range(len(dtList) - 1):
            if start is None:
                start = i#dtList[i][0]
                if (not (dtList[i + 1] - dtList[i]) <= dt.timedelta(minutes=1))\
                    or dtList[i + 1].second != 0:
                    stop = i

            elif (not (dtList[i + 1] - dtList[i]) == dt.timedelta(minutes=1))\
                    or dtList[i + 1].second != 0:
                stop = i

            if stop is not None:
                rngs += [[start, stop, dtList[start]]]
                start = None
                stop = None

        stop = i + 1#fileList[i+1][0]
        rngs += [[start, stop, dtList[start]]]

        return rngs

    def scanForFeatures(self):
        self.prepareFilelist()

        for root, dirs, files in os.walk(self.baseFolder):
            for f in sorted(files):
                for featDesc in self.featureLst:
                    if root.endswith(featDesc.path) \
                    and f.endswith(featDesc.ext):
                        vialNo = int(f[-(len(featDesc.ext) + 1)])
                        self.filelists[vialNo][featDesc] += [os.path.join(root, f)]

        v = self.filelists.keys()[0]
        fd = self.filelists[v].keys()[0]
        self.rngs = self.findInteruptions(self.filelists[v][fd], fd.ext)


class ClusterFeatureExtratorBase(object):
    def __init__(self, baseFolder, featureLst, targetFeat, batchIdx, startIdx, stopIdx, params=None, overlap=[0,0]):
        """
        param has to be an collections.OrderedDict
        """
        self.baseFolder = baseFolder
        if not type(featureLst) == list:
            featureLst = [featureLst]

        self.featureLst = featureLst
        self.targetFeat = targetFeat
        self.batchIdx = batchIdx
        self.lstRange = range(startIdx, stopIdx)
        self.overlap = overlap
        self.vialIdces = [0,1,2,3]

        if params is None:
            params = {}

        self.params = params

        self.ff = featureFilter(baseFolder, featureLst)


    def splitFolders(self, path):
        splits = []
        while path != '/' and path:
            path, folder = os.path.split(path)
            splits += [folder]

        splits.reverse()
        return splits

    def writeParameters(self, basefolder):
        paramString = "class: {name}\ntime: {time}\nparameters: {param}\nused features: {featLst}\nposition: {pos}"
        outString = paramString.format(name=self.__class__,
                                       time=dt.datetime.now(),
                                       param=self.params,
                                       featLst=self.featureLst,
                                       pos=str(self.batchIdx) + "-" + str(self.lstRange))

        with open(os.path.join(basefolder, "parameters.param"), 'w') as f:
            f.writelines(outString)

    def constructSaveDir(self, baseSaveDir, filename, featPath, appendix):
        folders = self.splitFolders(filename)
        fpl = len(self.splitFolders(featPath))

        if type(appendix) == list:
            baseFolder = os.path.join(baseSaveDir, folders[-3-fpl], folders[-2-fpl], *appendix)
        else:
            baseFolder = os.path.join(baseSaveDir, folders[-3-fpl], folders[-2-fpl], appendix)

        if not os.path.exists(baseFolder):
            os.makedirs(baseFolder)
            self.writeParameters(baseFolder)

        return baseFolder


    def createFeatureSavePath(self, i, v):
        srcFilename = self.ff.filelists[v][self.featureLst[0]][i]
        featPath = self.featureLst[0].path

        dirname = self.constructSaveDir(self.baseFolder, srcFilename, featPath, self.targetFeat.path)
        basename = os.path.basename(self.ff.filelists[v][self.featureLst[0]][i])
        basename = basename[:-len(self.featureLst[0].ext)]
        basename += self.targetFeat.ext

        return os.path.join(dirname, basename)



    def extractFeatures(self):
        b = self.batchIdx
        rangeLength = self.ff.rngs[b][1] - self.ff.rngs[b][0]

        for i in self.lstRange:
            if i > rangeLength:
                break

            idx = self.ff.rngs[b][0] + i
            for v in self.ff.filelists.keys():
                rng = slice(idx-self.overlap[0], idx + 1 +self.overlap[1])
                loc = slice(-self.overlap[0], self.overlap[1] + 1)
                if rng.start < 0:
                    rng = slice(0, rng.stop)
                    loc = slice(0, loc.stop)
                if rng.stop >= rangeLength:
                    stop = rng.stop - rangeLength
                    loc = slice(loc.start, loc.stop - stop)

                paths = []
                for featDesc in self.featureLst:
                    paths += [self.ff.filelists[v][featDesc][rng]]

                feat = self.calculateFeatures(paths, loc, v, **self.params)
                filename = self.createFeatureSavePath(idx, v)

                np.save(filename, feat)

    ############## CFG #################################
    def getNumberOfFiles(self):
        v = self.ff.filelists.keys()[0]
        return len(self.ff.filelists[v][self.featureLst[0]])

    def generateBaseString(self):
        baseString = '{0} {1} {2} {3} {4}'
        params = copy.copy(self.params)
        while params:
            baseString += " {{{0}}}".format(params.popitem(last=False)[0])

        baseString += " {addParams}\n"

        return baseString

    def generateScriptConfigString(self, noPerBatch, additionalParams):
        cfgString = ''
        baseString = self.generateBaseString()

        cnt = 0
        for batchIdx in range(len(self.ff.rngs)):
            nf = self.ff.rngs[batchIdx][1] - self.ff.rngs[batchIdx][0]
            for i in range(0, nf, noPerBatch):
                if i + noPerBatch > nf:
                    stop = nf
                else:
                    stop = i + noPerBatch
                cfgString += baseString.format(cnt,
                                               batchIdx,
                                               i,
                                               stop,
                                               self.baseFolder,
                                               addParams=additionalParams,
                                               **self.params)
                cnt += 1

        return cfgString



    def generateConfig(self, filename, noPerBatch=100, additionalParams=''):
        cfgString = self.generateScriptConfigString(noPerBatch, additionalParams)
        with open(filename, "w") as f:
            f.write(cfgString)


    ############## VIRTUAL FUNCTIONS ###################
    def calculateFeatures(self, paths, loc, v, **params):
        print paths
        print loc
        print params
        return np.zeros((10,1))



